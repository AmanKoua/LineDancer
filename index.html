<!DOCTYPE html>
<html>

    <body style="margin: 0px">
        <canvas id="canvas" style="border: 1px solid black; position: inline-block; margin:10px"></canvas>
        <!-- <img src="./person.jpg" id="img" style="visibility:hidden"/> -->
        <video src="personVid.mp4" id="vid" width="160" height="210" controls></video>
        <canvas id="imgCanvas" style="border: 1px solid red; position: inline-block; margin-left: 10px; visibility: hidden"></canvas>
        <input type="range" min="0" max="50" style="margin-top: 0px; display:block" id="distSlider"/>
        <button id="download">Download coordinate buffer</button>
        <p id="distText">Distance Treshold : </p>
    </body>
    <script>

        let canvasWidth = 160;
        let canvasHeight = 210;

        let imgCanvas = document.getElementById("imgCanvas");
        imgCanvas.width = canvasWidth;
        imgCanvas.height = canvasHeight;
        imgCtx = imgCanvas.getContext("2d");

        let canvas = document.getElementById("canvas");
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        ctx = canvas.getContext("2d");

        let time = 0;
        let distTresh = 10;
        let distTreshMult = 255 / distTresh;
        let dots = [];

        let img = document.getElementById("img");
        let imgXStart = -80;
        let imgYStart = -50;
        let imgWidth = 300;
        let imgHeight = 300;
        let validCoorBuffer = []; // [frameIdx][x][y]. 3d array
        let imageOpacity = 1;

        let vid = document.getElementById("vid");
        let vidDuration = undefined; // video duration in seconds
        let timeInterval = undefined; // interval for rendering video frames onto screen

        let isDownloadLocked = true;

        let distSlider = document.getElementById("distSlider");
        let distText = document.getElementById("distText");
        let dlButton = document.getElementById("download");

        distSlider.addEventListener("change", (e) => {
            distTresh = e.target.value;
            distText.innerHTML = "Distance Treshold : " + distTresh;
        })

        dlButton.addEventListener("click", (e) => {
            downloadValidCoorBuffer();
        })

        class Dot {
            constructor(x,y,xMult, yMult){
                this.x = x;
                this.y = y;
                this.r = .2;
                this.xMov = Math.random() *  xMult;
                this.yMov = Math.random() *  yMult;
            }

            updatePos(canvas){
                this.x += this.xMov;
                this.y += this.yMov;

                if(this.x > canvas.width || this.x < 0){
                    this.xMov *= -1;
                }

                if(this.y > canvas.height || this.y < 0){
                    this.yMov *= -1;
                }

            }

            getDist(other){
                return Math.sqrt(Math.pow((this.x - other.x),2) + Math.pow((this.y - other.y),2));
            }

            getIsValidCoor(){
                let colorData = imgCtx.getImageData(this.x,this.y, 1, 1);

                if(colorData[3] == 0){ // if not in image boundary
                    return false;
                }

                if(colorData[0] + colorData[1] + colorData[2] < 10){ // if black or very dark pixel
                    return true;
                }

                return false;
            }   

            drawLines(){

                /*
                    For each dot in the dots array, check if the dist is below the dist thresh, and that they're both in valid
                    image portions. If so, draw a line between them.
                */

                for(let i = 0; i < dots.length; i++){
                    let tempDist = this.getDist(dots[i])
                    // if(tempDist < (Math.sin(time) * distTresh)){ // makes distTresh oscillate up and down
                    if(tempDist < (distTresh)){
                        try{

                            /*
                                Determining if a coordinate is valid or not in real-time is far too CPU intensive. A validCoorBuffer must be utilized
                            */

                            if(validCoorBuffer[time][Math.floor(this.x)][Math.floor(this.y)] == 1 && validCoorBuffer[time][Math.floor(dots[i].x)][Math.floor(dots[i].y)] == 1){
                                ctx.beginPath();
                                ctx.moveTo(this.x,this.y);
                                ctx.lineTo(dots[i].x, dots[i].y);
                                ctx.lineWidth = .3;
                                // ctx.strokeStyle = `rgb(${255 - tempDist*distTreshMult}, 0, ${tempDist})`
                                ctx.stroke();
                            }
                        }
                        catch(e){ // weid bug workaround
                            continue;
                        }
                    }
                }
            }

        };

        let initDots = (count, xMult, yMult) => {
            for(let i = 0; i < count; i++){
                let temp = new Dot(Math.random() * (canvas.width-50), Math.random() * (canvas.height - 50), xMult, yMult);
                dots.push(temp);
            }
        }

        let drawDot = (canvas,ctx, dot) => {
            dot.drawLines();
            ctx.beginPath();
            ctx.arc(dot.x, dot.y, dot.r, 0, 2 * Math.PI);
            ctx.fill();
            dot.updatePos(canvas);
            ctx.lineWidth = 1;
            ctx.strokeStyle = "rgb(0,0,0)"
            ctx.stroke();
        }

        let draw = () => {

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            for(let i = 0 ; i < dots.length; i++){
                drawDot(canvas,ctx,dots[i]);
            }

            requestAnimationFrame(draw);

        }

        // window.onmousemove = (e) => { // get colorData at idx and log to console.
        //     let mouseX;
        //     let mouseY;
        //     mouseX = e.clientX;
        //     mouseY = e.clientY;
        //     let colorData = imgCtx.getImageData(mouseX,mouseY, 1, 1);
        //     console.log(colorData.data[0],colorData.data[1],colorData.data[2],colorData.data[3]);
        // }

        // window.onmousemove = (e) => { // getValidCoorBuffer result at idx and log to console.
        //     let mouseX;
        //     let mouseY;
        //     mouseX = e.clientX;
        //     mouseY = e.clientY;
        //     console.log(validCoorBuffer[mouseX][mouseY], mouseX, mouseY);
        //     // console.log(isValidImgCoor(mouseX, mouseY));
        // }

        // window.onmousemove = (e) => { // Use mouse postion to play around with dist tresh (old technique)
        //     let mouseX;
        //     let mouseY;
        //     mouseX = e.clientX;  
        //     mouseY = e.clientY;
        //     distTresh = mouseX / 10;
        // }

        let getVideoDuration = () => {

            return new Promise((res,rej) => {

                let temp = setInterval(()=>{

                    console.log(vid.duration);

                    if(vid.duration == NaN){
                        // do nothing
                    }
                    else{
                        vidDuration = vid.duration;
                        clearInterval(temp);
                        res();
                    }

                },100)

            })

        }

        let generateVidValidCoorBuffer = async (stepSize) => {

            while(vid.currentTime != vidDuration){ // draw on canvas, create buffer and store at frame idx, play video for stepSize ms, repeat
                imgCtx.drawImage(vid, imgXStart,imgYStart, imgWidth, imgHeight);
                await generateValidCoorBuffer(time);                
                await progressVideo(stepSize);
                time++;
            }

            time = 0;
            isDownloadLocked = false; // allow for valid coor buffer downloading

        }

        let generateValidCoorBuffer = (time) => { // works

            return new Promise((res, rej) => {

                temp = []

                for(let x = 0; x < canvasWidth + 1; x++){
                    let yBuff = [];
                    for(let y = 0; y < canvasHeight + 1; y++){

                        if(isValidImgCoor(x,y)){
                            yBuff[y] = 1;
                        }
                        else{
                            yBuff[y] = 0;
                        }   

                    }
                    temp[x] = yBuff;
                }

                validCoorBuffer[time] = temp;
                res();

            });

        }

        let downloadValidCoorBuffer = () => {

            if(isDownloadLocked){
                alert("Cannot download buffer before / during buffer creation!");
                return;
            }

            let link = document.createElement("a");
            let bufferJSON = JSON.stringify(validCoorBuffer);
            let blob = new Blob([bufferJSON], {type:'text/plain'});
            let downloadURL = URL.createObjectURL(blob);
            link.href = downloadURL;
            link.setAttribute('download', "validCoorBuffer.txt");
            link.click();
        }

        let isValidImgCoor = (x, y) => { // works

            if(x < imgXStart || x > imgXStart + imgWidth){
                return false;
            }

            if( y < imgYStart || y > imgYStart + imgHeight){
                return false;
            }

            let colorData = imgCtx.getImageData(x,y,1,1);

            if(colorData.data[0] + colorData.data[1] + colorData.data[2] < 15){ // if color is very dark (black), valid
                return true;
            }

            return false;
        }

        let progressVideo = (stepSize) => {

            // console.log("playing vid!");

            return new Promise(async (res,rej) => {
              
                await vid.play();

                setTimeout( ()=>{
                    vid.pause();
                    res();
                },stepSize);

            })

        }

        let setTimeInterval = (stepSize) => {
            timeInterval = setInterval(()=>{
                time++;
                time %= validCoorBuffer.length;
            }, stepSize);
        }

        let sleep = (time) => { // sleep util function
            return new Promise((res, rej) => {
                setTimeout(()=>{res()},time);
            });
        }

        let main = async () => {

            let stepSize = 1000; // frame diff, in ms, to break video into. 16.77 = aprox 60 FPS

            await getVideoDuration();
            await sleep(200);
            await generateVidValidCoorBuffer(stepSize);
            initDots(1000, 1,1);
            await sleep(200);
            draw();
            setTimeInterval(stepSize)
        }

        main();

        /*
            NOTES:

            APPLICATION WILL ONLY RUN WHEN SERVED FROM LOCALHOST. Run application from
            simply python server with "python -m http.server 8000" for python 3.x

            InitDots(count) determines the number of dots
            distTresh determines the distance threshold for drawing lines between 2 dots.

            without sleeping in the main function, drawing image and generating buffer fails (sometimes).
            Refresh of page is required in those instances.

            -----------------------------------------------------------------------------------------------

            For some reason, google chrome does not allow one to set the currentTime attibute of a video.
            The solution will be to create a buffer, play the video for a couple ms, pause the video at
            that frame, and then create the buffer at that frame idx.

            -----------------------------------------------------------------------------------------------

            all images / videos are AI generated

        */

    </script>

</html>