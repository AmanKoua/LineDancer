<!DOCTYPE html>
<html>

    <body style="margin: 0px">
        <canvas id="canvas" style="border: 1px solid black; position: inline-block; margin:10px"></canvas>
        <!-- <img src="./person.jpg" id="img" style="visibility:hidden"/> -->
        <video src="personVid.mp4" id="vid" width="160" height="210" controls></video>
        <canvas id="imgCanvas" style="border: 1px solid red; position: inline-block; margin-left: 10px; visibility: hidden"></canvas>
        <input type="range" min="0" max="50" style="margin-top: 0px; display:block" id="distSlider"/>
        <p id="distText">Distance Treshold : </p>   
        <input type="range" min="16" max="1000" style="margin-top: 0px; display:block" id="stepSlider"/>
        <p id="stepText">Step size : </p>   
        <button id="download">Download coordinate buffer</button>
        <input id="bufferFileInput" type="file" accept="text/plain"></input>
        <button id="toggleDots" style="display:block; margin-top:10px">Toggle Dots</button>

    </body>
    <script>

        let canvasWidth = 160;
        let canvasHeight = 210;

        let imgCanvas = document.getElementById("imgCanvas");
        imgCanvas.width = canvasWidth;
        imgCanvas.height = canvasHeight;
        imgCtx = imgCanvas.getContext("2d");

        let canvas = document.getElementById("canvas");
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        ctx = canvas.getContext("2d");

        let stepSize = 30; // frame diff, in ms, to break video into. 16.77 = aprox 60 FPS
        let isStepSizeLocked = true;
        let time = 0; // important for generating valid coor buffer, and indexing in generated / loaded coor buffer
        let modTime = 0;
        let distTresh = 10;
        let distTreshMult = 255 / distTresh;
        let dots = [];
        let renderDots = true;

        let img = document.getElementById("img");
        let imgXStart = -80;
        let imgYStart = -50;
        let imgWidth = 300;
        let imgHeight = 300;
        let validCoorBuffer = []; // [frameIdx][x][y]. 3d array
        let imageOpacity = 1;

        let vid = document.getElementById("vid");
        let vidDuration = undefined; // video duration in seconds
        let timeInterval = undefined; // interval for rendering video frames onto screen

        let isDownloadLocked = true;

        let distSlider = document.getElementById("distSlider");
        let stepSlider = document.getElementById("stepSlider");
        let stepText = document.getElementById("stepText");
        let distText = document.getElementById("distText");
        let dlButton = document.getElementById("download");
        let toggleDotsButton = document.getElementById("toggleDots");
        let bufferFileInput = document.getElementById("bufferFileInput");

        distSlider.addEventListener("change", (e) => {
            distTresh = e.target.value;
            distText.innerHTML = "Distance Treshold : " + distTresh;
        })

        stepSlider.addEventListener("change", (e) => {

            if(isStepSizeLocked){
                return;
            }

            stepSize = e.target.value;
            stepText.innerHTML = "Step size : " + stepSize;

            clearInterval(timeInterval);
            setTimeInterval(stepSize);

        })

        dlButton.addEventListener("click", (e) => {
            downloadValidCoorBuffer();
        })

        toggleDotsButton.addEventListener("click", (e)=>{
            renderDots = !renderDots;
        })

        bufferFileInput.addEventListener("change", (e) => {

            if(!bufferFileInput.files || bufferFileInput.files.length == 0){
                return;
            }

            let reader = new FileReader();
            
            reader.onload = function (e){
                // console.log(typeof e.target.result);
                validCoorBuffer = JSON.parse(e.target.result);
            }

            reader.readAsText(bufferFileInput.files[0]);
        })

        class Dot {
            constructor(x,y,xMult, yMult){
                this.x = x;
                this.y = y;
                this.r = .2;
                this.xMov = Math.random() *  xMult;
                this.yMov = Math.random() *  yMult;
            }

            updatePos(canvas){

                // let speedMult = Math.sin(modTime) > 0 ? Math.sin(modTime) : Math.sin(modTime) * -1;
                // this.x += this.xMov * speedMult;
                // this.y += this.yMov * speedMult;

                this.x += this.xMov * 2;
                this.y += this.yMov * 2;

                if(this.x > canvas.width || this.x < 0){
                    this.xMov *= -1;
                }

                if(this.y > canvas.height || this.y < 0){
                    this.yMov *= -1;
                }

            }

            getDist(other){
                return Math.sqrt(Math.pow((this.x - other.x),2) + Math.pow((this.y - other.y),2));
            }

            getIsValidCoor(){
                let colorData = imgCtx.getImageData(this.x,this.y, 1, 1);

                if(colorData[3] == 0){ // if not in image boundary
                    return false;
                }

                if(colorData[0] + colorData[1] + colorData[2] < 10){ // if black or very dark pixel
                    return true;
                }

                return false;
            }   

            drawLines(){

                /*
                    For each dot in the dots array, check if the dist is below the dist thresh, and that they're both in valid
                    image portions. If so, draw a line between them.
                */

                let lineCount = 0;

                for(let i = 0; i < dots.length; i++){
                    let tempDist = this.getDist(dots[i])
                    // if(tempDist < (Math.sin(time) * distTresh)){ // makes distTresh oscillate up and down
                    if(tempDist < (distTresh)){
                        try{
                            if(validCoorBuffer[time][Math.floor(this.x)][Math.floor(this.y)] == 1 && validCoorBuffer[time][Math.floor(dots[i].x)][Math.floor(dots[i].y)] == 1){
                                ctx.beginPath();
                                ctx.moveTo(this.x,this.y);
                                ctx.lineTo(dots[i].x, dots[i].y);
                                ctx.lineWidth = .3;
                                // ctx.strokeStyle = `rgb(${255 - tempDist*distTreshMult}, 0, ${tempDist})`
                                ctx.stroke();

                                lineCount++;
                                if(lineCount > distTresh){ // attempting some optimization
                                    break;
                                }

                            }
                        }
                        catch(e){ // weid bug workaround
                            continue;
                        }
                    }
                }
            }

        };

        let initDots = (count, xMult, yMult) => {
            for(let i = 0; i < count; i++){
                let temp = new Dot(Math.random() * (canvas.width-50), Math.random() * (canvas.height - 50), xMult, yMult);
                dots.push(temp);
            }
        }

        let drawDot = (canvas,ctx, dot) => {

            if(renderDots){
                dot.drawLines();
                ctx.beginPath();
                ctx.arc(dot.x, dot.y, dot.r, 0, 2 * Math.PI);
                ctx.fill();
                dot.updatePos(canvas);
                ctx.lineWidth = 1;
                ctx.strokeStyle = "rgb(0,0,0)"
                ctx.stroke();
            }
            else{
                dot.drawLines();
                // ctx.beginPath();
                // ctx.arc(dot.x, dot.y, dot.r, 0, 2 * Math.PI);
                // ctx.fill();
                dot.updatePos(canvas);
                // ctx.lineWidth = 1;
                // ctx.strokeStyle = "rgb(0,0,0)"
                // ctx.stroke();
            }

        }

        let draw = (drawDots) => {

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            for(let i = 0 ; i < dots.length; i++){
                drawDot(canvas,ctx,dots[i]);
            }

            requestAnimationFrame(draw);

        }

        // window.onmousemove = (e) => { // get colorData at idx and log to console.
        //     let mouseX;
        //     let mouseY;
        //     mouseX = e.clientX;
        //     mouseY = e.clientY;
        //     let colorData = imgCtx.getImageData(mouseX,mouseY, 1, 1);
        //     console.log(colorData.data[0],colorData.data[1],colorData.data[2],colorData.data[3]);
        // }

        // window.onmousemove = (e) => { // getValidCoorBuffer result at idx and log to console.
        //     let mouseX;
        //     let mouseY;
        //     mouseX = e.clientX;
        //     mouseY = e.clientY;
        //     console.log(validCoorBuffer[mouseX][mouseY], mouseX, mouseY);
        //     // console.log(isValidImgCoor(mouseX, mouseY));
        // }

        // window.onmousemove = (e) => { // Use mouse postion to play around with dist tresh (old technique)
        //     let mouseX;
        //     let mouseY;
        //     mouseX = e.clientX;  
        //     mouseY = e.clientY;
        //     distTresh = mouseX / 10;
        // }

        let getVideoDuration = () => {

            return new Promise((res,rej) => {

                let temp = setInterval(()=>{

                    // console.log(vid.duration);

                    if(vid.duration == NaN){
                        // do nothing
                    }
                    else{
                        vidDuration = vid.duration;
                        clearInterval(temp);
                        res();
                    }

                },100)

            })

        }

        let generateVidValidCoorBuffer = async (stepSize) => {

            while(vid.currentTime != vidDuration){ // draw on canvas, create buffer and store at frame idx, play video for stepSize ms, repeat
                imgCtx.drawImage(vid, imgXStart,imgYStart, imgWidth, imgHeight);
                await generateValidCoorBuffer(time);                
                await progressVideo(stepSize);
                time++;
            }

            time = 0;
            isDownloadLocked = false; // allow for valid coor buffer downloading
        }

        let generateValidCoorBuffer = (time) => { // works

            return new Promise((res, rej) => {

                temp = []

                for(let x = 0; x < canvasWidth + 1; x++){
                    let yBuff = [];
                    for(let y = 0; y < canvasHeight + 1; y++){

                        if(isValidImgCoor(x,y)){
                            yBuff[y] = 1;
                        }
                        else{
                            yBuff[y] = 0;
                        }   

                    }
                    temp[x] = yBuff;
                }

                validCoorBuffer[time] = temp;
                res();

            });

        }

        let downloadValidCoorBuffer = () => {

            if(isDownloadLocked){
                // alert("Cannot download buffer before / during buffer creation!");
                return;
            }

            let link = document.createElement("a");
            let bufferJSON = JSON.stringify(validCoorBuffer);
            let blob = new Blob([bufferJSON], {type:'text/plain'});
            let downloadURL = URL.createObjectURL(blob);
            link.href = downloadURL;
            link.setAttribute('download', "validCoorBuffer.txt");
            link.click();
        }

        let isValidImgCoor = (x, y) => { // works

            if(x < imgXStart || x > imgXStart + imgWidth){
                return false;
            }

            if( y < imgYStart || y > imgYStart + imgHeight){
                return false;
            }

            let colorData = imgCtx.getImageData(x,y,1,1);

            if(colorData.data[0] + colorData.data[1] + colorData.data[2] < 15){ // if color is very dark (black), valid
                return true;
            }

            return false;
        }

        let progressVideo = (stepSize) => {

            // console.log("playing vid!");

            return new Promise(async (res,rej) => {
              
                await vid.play();

                setTimeout( ()=>{
                    vid.pause();
                    res();
                },stepSize);

            })

        }

        let setTimeInterval = (stepSize) => {
            timeInterval = setInterval(()=>{
                time++;
                time %= validCoorBuffer.length;
            }, stepSize);
        }

        let setModTimeInterval = () => {
            setInterval(() => {
                modTime += .1;
                modTime %= Math.PI * 2;
            },33)
        }

        let sleep = (time) => { // sleep util function
            return new Promise((res, rej) => {
                setTimeout(()=>{res()},time);
            });
        }

        let main = async () => {

            stepSize = 500; // frame diff, in ms, to break video into. 16.77 = aprox 60 FPS

            await getVideoDuration();
            await sleep(200);
            await generateVidValidCoorBuffer(stepSize);
            initDots(1000, 1,1);
            await sleep(200);
            draw();
            setTimeInterval(stepSize)
            setModTimeInterval();

            isStepSizeLocked = false;
        }

        main();

        /*
            NOTES:

            APPLICATION WILL ONLY RUN WHEN SERVED FROM LOCALHOST. Run application from
            simply python server with "python -m http.server 8000" for python 3.x

            InitDots(count) determines the number of dots
            distTresh determines the distance threshold for drawing lines between 2 dots.

            without sleeping in the main function, drawing image and generating buffer fails (sometimes).
            Refresh of page is required in those instances.

            -----------------------------------------------------------------------------------------------

            For some reason, google chrome does not allow one to set the currentTime attibute of a video.
            The solution will be to create a buffer, play the video for a couple ms, pause the video at
            that frame, and then create the buffer at that frame idx.

            -----------------------------------------------------------------------------------------------

            all images / videos are AI generated
        */

    </script>

</html>